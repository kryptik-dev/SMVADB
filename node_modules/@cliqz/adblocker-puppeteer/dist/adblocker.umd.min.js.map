{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parse } from 'tldts-experimental';\nimport { FiltersEngine, Request } from '@cliqz/adblocker';\nimport { autoRemoveScript, extractFeaturesFromDOM, DOMMonitor } from '@cliqz/adblocker-content';\nfunction sleep(milliseconds) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, milliseconds);\n    });\n}\nfunction getTopLevelUrl(frame) {\n    let sourceUrl = '';\n    while (frame !== null) {\n        sourceUrl = frame.url();\n        if (sourceUrl.length !== 0) {\n            break;\n        }\n        frame = frame.parentFrame();\n    }\n    return sourceUrl;\n}\n/**\n * Create an instance of `Request` from `puppeteer.Request`.\n */\nexport function fromPuppeteerDetails(details) {\n    const sourceUrl = getTopLevelUrl(details.frame());\n    const url = details.url();\n    const type = details.resourceType();\n    return Request.fromRawDetails({\n        _originalRequestDetails: details,\n        requestId: `${type}-${url}-${sourceUrl}`,\n        sourceUrl,\n        type,\n        url,\n    });\n}\n/**\n * Wrap `FiltersEngine` into a Puppeteer-friendly helper class.\n */\nexport class BlockingContext {\n    constructor(page, blocker) {\n        this.page = page;\n        this.blocker = blocker;\n        this.onFrameNavigated = (frame) => blocker.onFrameNavigated(frame);\n        this.onDomContentLoaded = () => blocker.onFrameNavigated(this.page.mainFrame());\n        this.onRequest = (request) => blocker.onRequest(request);\n    }\n    async enable() {\n        if (this.blocker.config.loadCosmeticFilters) {\n            // Register callbacks to cosmetics injection (CSS + scriptlets)\n            this.page.on('frameattached', this.onFrameNavigated);\n            this.page.on('domcontentloaded', this.onDomContentLoaded);\n        }\n        if (this.blocker.config.loadNetworkFilters) {\n            // Make sure request interception is enabled for `page` before proceeding\n            await this.page.setRequestInterception(true);\n            // NOTES:\n            //  - page.setBypassCSP(enabled) might be needed to perform\n            //  injections on some pages.\n            //  - we currently do not perform CSP headers injection as there is\n            //  currently no way to modify responses in puppeteer. This feature could\n            //  easily be added if puppeteer implements the required capability.\n            //\n            // Register callback for network requests filtering.\n            this.page.on('request', this.onRequest);\n        }\n    }\n    async disable() {\n        if (this.blocker.config.loadNetworkFilters) {\n            this.page.off('request', this.onRequest);\n            await this.page.setRequestInterception(false);\n        }\n        if (this.blocker.config.loadCosmeticFilters) {\n            this.page.off('frameattached', this.onFrameNavigated);\n            this.page.off('domcontentloaded', this.onDomContentLoaded);\n        }\n    }\n}\n/**\n * Wrap `FiltersEngine` into a Puppeteer-friendly helper class. It exposes\n * methods to interface with Puppeteer APIs needed to block ads.\n */\nexport class PuppeteerBlocker extends FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        // Defaults to undefined which preserves Legacy Mode behavior\n        this.priority = undefined;\n        // ----------------------------------------------------------------------- //\n        // PuppeteerBlocker-specific additions to FiltersEngine\n        // ----------------------------------------------------------------------- //\n        this.onFrameNavigated = async (frame) => {\n            try {\n                await this.onFrame(frame);\n            }\n            catch (ex) {\n                // Ignore\n            }\n        };\n        this.onFrame = async (frame) => {\n            const url = frame.url();\n            if (url === 'chrome-error://chromewebdata/') {\n                return;\n            }\n            // Look for all iframes in this context and check if they should be removed\n            // from the DOM completely. For this we check if their `src` or `href`\n            // attribute would be blocked by any network filter.\n            this.removeBlockedFrames(frame).catch(() => {\n                /* ignore */\n            });\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            // We first query for stylesheets and scriptlets which are either generic or\n            // based on the hostname of this frame. We need to get these as fast as\n            // possible to reduce blinking when page loads.\n            {\n                // TODO - implement extended filters for Puppeteer\n                const { active, styles, scripts /* , extended */ } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    // Done once per frame.\n                    getBaseRules: true,\n                    getInjectionRules: true,\n                    getExtendedRules: true,\n                    getRulesFromHostname: true,\n                    // Will handle DOM features (see below).\n                    getRulesFromDOM: false,\n                });\n                if (active === false) {\n                    return;\n                }\n                Promise.all([\n                    this.injectScriptletsIntoFrame(frame, scripts),\n                    this.injectStylesIntoFrame(frame, styles),\n                ]).catch(() => {\n                    /* ignore */\n                });\n            }\n            // Seconde step is to start monitoring the DOM of the page in order to\n            // inject more specific selectors based on `id`, `class`, or `href` found on\n            // nodes. We first query all of them, then monitor the DOM for a few\n            // seconds (or until one of the stopping conditions is met, see below).\n            const observer = new DOMMonitor((update) => {\n                if (update.type === 'features') {\n                    const { active, styles } = this.getCosmeticsFilters({\n                        domain,\n                        hostname,\n                        url,\n                        // DOM information\n                        ...update,\n                        // Only done once per frame (see above).\n                        getBaseRules: false,\n                        getInjectionRules: false,\n                        getExtendedRules: false,\n                        getRulesFromHostname: false,\n                        // Allows to get styles for updated DOM.\n                        getRulesFromDOM: true,\n                    });\n                    // Abort if cosmetics are disabled\n                    if (active === false) {\n                        return;\n                    }\n                    this.injectStylesIntoFrame(frame, styles).catch(() => {\n                        /* ignore */\n                    });\n                }\n            });\n            // This loop will periodically check if any new custom styles should be\n            // injected in the page (using values of attributes `id`, `class`, or `href`).\n            //\n            // We stop looking in the following cases:\n            // * Frame was detached.\n            // * No new attribute was found.\n            // * Number of iterations exceeded 10 (i.e. 5 seconds).\n            // * Exception was raised.\n            //\n            // Additionally, we might stop after the first lookup if\n            // `enableMutationObserver` is disabled in config, which means that we\n            // should not actively monitor the DOM for changes.\n            let numberOfIterations = 0;\n            do {\n                if (frame.isDetached()) {\n                    break;\n                }\n                try {\n                    const foundNewFeatures = observer.handleNewFeatures(await frame.$$eval(':root', extractFeaturesFromDOM));\n                    numberOfIterations += 1;\n                    if (numberOfIterations === 10) {\n                        break;\n                    }\n                    if (foundNewFeatures === false) {\n                        break;\n                    }\n                }\n                catch (ex) {\n                    break;\n                }\n                if (this.config.enableMutationObserver === false) {\n                    break;\n                }\n                await sleep(500);\n                // eslint-disable-next-line no-constant-condition\n            } while (true);\n        };\n        this.setRequestInterceptionPriority = (defaultPriority = 0) => (this.priority = defaultPriority);\n        this.onRequest = (details) => {\n            var _a, _b, _c;\n            if ((_a = details.isInterceptResolutionHandled) === null || _a === void 0 ? void 0 : _a.call(details)) {\n                return;\n            }\n            const request = fromPuppeteerDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            const frame = details.frame();\n            if (request.isMainFrame() ||\n                (request.type === 'document' && frame !== null && frame.parentFrame() === null)) {\n                details.continue((_b = details.continueRequestOverrides) === null || _b === void 0 ? void 0 : _b.call(details), 0);\n                return;\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect !== undefined) {\n                if (redirect.contentType.endsWith(';base64')) {\n                    details.respond({\n                        status: 200,\n                        headers: {},\n                        body: Buffer.from(redirect.body, 'base64'),\n                        contentType: redirect.contentType.slice(0, -7),\n                    }, this.priority);\n                }\n                else {\n                    details.respond({\n                        status: 200,\n                        headers: {},\n                        body: redirect.body,\n                        contentType: redirect.contentType,\n                    }, this.priority);\n                }\n            }\n            else if (match === true) {\n                details.abort('blockedbyclient', this.priority);\n            }\n            else {\n                details.continue((_c = details.continueRequestOverrides) === null || _c === void 0 ? void 0 : _c.call(details), 0);\n            }\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    async enableBlockingInPage(page) {\n        let context = this.contexts.get(page);\n        if (context !== undefined) {\n            return context;\n        }\n        context = new BlockingContext(page, this);\n        this.contexts.set(page, context);\n        await context.enable();\n        return context;\n    }\n    async disableBlockingInPage(page) {\n        const context = this.contexts.get(page);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(page);\n        await context.disable();\n    }\n    isBlockingEnabled(page) {\n        return this.contexts.has(page);\n    }\n    async injectStylesIntoFrame(frame, styles) {\n        if (styles.length !== 0) {\n            await frame.addStyleTag({\n                content: styles,\n            });\n        }\n    }\n    async injectScriptletsIntoFrame(frame, scripts) {\n        const promises = [];\n        if (scripts.length !== 0) {\n            for (let i = 0; i < scripts.length; i += 1) {\n                promises.push(frame\n                    .addScriptTag({\n                    content: autoRemoveScript(scripts[i]),\n                })\n                    .then(() => {\n                    /* Ignore result */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n    /**\n     * Look for sub-frames in `frame`, check if their `src` or `href` would be\n     * blocked, and then proceed to removing them from the DOM completely.\n     */\n    async removeBlockedFrames(frame) {\n        const promises = [];\n        const sourceUrl = getTopLevelUrl(frame);\n        for (const url of await frame.$$eval('iframe[src],iframe[href]', (elements) => elements.map(({ src, href }) => src || href))) {\n            const { match } = this.match(Request.fromRawDetails({\n                url,\n                sourceUrl,\n                type: 'sub_frame',\n            }));\n            if (match) {\n                promises.push(frame\n                    .$$eval(`iframe[src=\"${url}\"],iframe[href=\"${url}\"]`, (iframes) => {\n                    var _a;\n                    for (const iframe of iframes) {\n                        (_a = iframe === null || iframe === void 0 ? void 0 : iframe.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(iframe);\n                    }\n                })\n                    .catch(() => {\n                    /* ignore */\n                }));\n            }\n        }\n        await Promise.all(promises);\n    }\n}\n// Re-export symboles from @cliqz/adblocker for convenience\nexport * from '@cliqz/adblocker';\n//# sourceMappingURL=index.js.map"],"names":["sleep","milliseconds","Promise","resolve","setTimeout","getTopLevelUrl","frame","sourceUrl","url","length","parentFrame","fromPuppeteerDetails","details","type","resourceType","Request","fromRawDetails","_originalRequestDetails","requestId","BlockingContext","constructor","page","blocker","this","onFrameNavigated","onDomContentLoaded","mainFrame","onRequest","request","enable","config","loadCosmeticFilters","on","loadNetworkFilters","setRequestInterception","disable","off","PuppeteerBlocker","FiltersEngine","super","arguments","contexts","WeakMap","priority","undefined","async","onFrame","ex","removeBlockedFrames","catch","parsed","parse","hostname","domain","active","styles","scripts","getCosmeticsFilters","getBaseRules","getInjectionRules","getExtendedRules","getRulesFromHostname","getRulesFromDOM","all","injectScriptletsIntoFrame","injectStylesIntoFrame","observer","DOMMonitor","update","numberOfIterations","isDetached","foundNewFeatures","handleNewFeatures","$$eval","extractFeaturesFromDOM","enableMutationObserver","setRequestInterceptionPriority","defaultPriority","_a","_b","_c","isInterceptResolutionHandled","call","guessRequestTypeFromUrl","guessTypeOfRequest","isMainFrame","continue","continueRequestOverrides","redirect","match","contentType","endsWith","respond","status","headers","body","Buffer","from","slice","abort","enableBlockingInPage","context","get","set","disableBlockingInPage","Error","delete","isBlockingEnabled","has","addStyleTag","content","promises","i","push","addScriptTag","autoRemoveScript","then","elements","map","src","href","iframes","iframe","parentNode","removeChild"],"mappings":"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"}